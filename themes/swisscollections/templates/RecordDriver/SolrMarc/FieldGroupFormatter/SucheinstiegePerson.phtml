<?php

namespace SwissCollections\templates\RecordDriver\SolrMarc\FieldGroupFormatter;

use SwissCollections\Formatter\FieldFormatterData;
use SwissCollections\Formatter\FieldGroupFormatter;
use SwissCollections\RecordDriver\FieldGroupRenderContext;
use SwissCollections\RecordDriver\FieldRenderContext;
use SwissCollections\RenderConfig\AbstractRenderConfigEntry;
use SwissCollections\RenderConfig\CompoundEntry;

class SucheinstiegePerson extends FieldGroupFormatter {

    public static $RENDER_CONFIG_PERSON_KEY = "Person";

    public function getName(): String {
        return "sucheinstiege-person";
    }

    /**
     * Die Personen nach ihren Funktionen gruppiert ausgeben.
     * 1xx/7xx$4: Urheber (aut, cmp, Rollen zu definieren, vgl. Primo, e-manuscripta)
     * 7xx$4: Beteiligte (inkl. Rollen)
     * 7xx$4rcp: AdressatIn
     * z.B. http://127.0.0.1/Record/990115273800205508
     * @param String $fieldName
     * @param AbstractRenderConfigEntry[] $fieldDataList
     * @param FieldGroupRenderContext $context
     */
    public function render($fieldName, &$fieldDataList, &$context): void {
        echo "<!-- START SUCHEINSTIEGE-PERSON -->\n";

        // bucket sort by role ("unknown" if no role is assigned)
        $personsWithRole = $this->fillRoleBuckets($fieldDataList, $context);
        $partialRoleOrder = $fieldDataList[0]->getFieldGroupFormatter()->getRoleOrder();
        $roles = $this->sortRoles(array_keys($personsWithRole), $partialRoleOrder);

        // render role buckets ...
        echo "\n<div class='row'>\n";
        echo "\t<div class='field-label field-label-" . SucheinstiegePerson::$RENDER_CONFIG_PERSON_KEY . " col-md-3'>\n";
        echo $this->phpRenderer->translate('page.detail.field.label.' . SucheinstiegePerson::$RENDER_CONFIG_PERSON_KEY);
        echo "\t</div>\n";
        echo "\t<div class='col-md-9'>\n";
        $fieldContext = new FieldRenderContext($context->fieldFormatterRegistry, $context->solrMarc);
        foreach ($roles as $role) {
            $persons = $personsWithRole[$role];
            echo "<h3 class='field-label field-label-" . SucheinstiegePerson::$RENDER_CONFIG_PERSON_KEY . "-role'>";
            if ($role === "unknown") {
                echo $this->phpRenderer->translate('page.detail.field.label.' . SucheinstiegePerson::$RENDER_CONFIG_PERSON_KEY . ".unknown-role");
            } else {
                echo $context->solrMarc->getTranslator()->translate($role, 'CreatorRoles');
            }
            echo "</h3>\n";
            /**
             * @var CompoundEntry $renderElem
             * @var FieldFormatterData[] $ffdList
             */
            foreach ($persons as list($renderElem, $ffdList)) {
                $renderElem->renderImpl($ffdList, $fieldContext);
            }
        }
        echo "\t</div>\n";
        echo "</div>\n";

        // TODO remove old block below which prints default values
        foreach ($fieldDataList as $renderElem) {
            echo "\n<div class='row'>\n";
            echo "\t<div class='field-label field-label-" . $renderElem->labelKey . " col-md-3'>\n";
            echo $this->phpRenderer->translate('page.detail.field.label.' . $renderElem->labelKey);
            echo "\t</div>\n";
            echo "\t<div class='col-md-9'>\n";

            // sets list element tags for repeated fields (see $this->outputField() call below)
            $renderElem->setListHtml("\t\t<li class='field-values-element'>\n", "\t\t</li>\n");
            $this->outputField($renderElem,
                $context, "\t\t<ul class='field-values'>\n", "\t\t</ul>\n");

            echo "\t</div>\n";
            echo "</div>\n";
        }
        echo "<!-- END SUCHEINSTIEGE-PERSON -->\n";
    }

    /**
     * @param String[] $roles
     * @param String[] $partialOrder
     */
    protected function sortRoles($roles, $partialOrder) {
        $newRoles = $partialOrder;
        // add all missing roles too ...
        foreach ($roles as $r) {
            if (!in_array($r, $newRoles)) {
                $newRoles[] = $r;
            }
        }
        return $newRoles;
    }

    /**
     * Sort persons into buckets of roles. If no role is present "unknown" is used.
     *
     * @param AbstractRenderConfigEntry[] $fieldDataList
     * @param FieldGroupRenderContext $context
     * @return array with role keys and a list of tuples. Each tuple consists of an CompoundEntry and
     *          FieldFormatterData[] (= values)
     */
    protected function fillRoleBuckets(&$fieldDataList, &$context): array {
        $roleMarcSubfields = $fieldDataList[0]->getFieldGroupFormatter()->getRoleMarcSubfields();
        $hiddenMarcSubfields = $fieldDataList[0]->getFieldGroupFormatter()->getHiddenRoleMarcSubfields();

        $personsWithRole = [];
        /**
         * @var CompoundEntry $renderElem
         */
        foreach ($fieldDataList as $renderElem) {
            $marcIndex = $renderElem->marcIndex;
            $subfieldValues = $context->solrMarc->getMarcSubfieldsRawMap($marcIndex);
            if (!empty($subfieldValues)) {
                foreach ($subfieldValues as $sfv) {
                    $role = "unknown";
                    foreach ($roleMarcSubfields as $roleSubfieldName) {
                        if (!empty($sfv[$roleSubfieldName])) {
                            $role = $sfv[$roleSubfieldName];
                            break;
                        }
                    }
                    $compoundEntry = $renderElem->flatCloneEntry();
                    foreach ($sfv as $subfieldNameStr => $value) {
                        if (in_array($subfieldNameStr, $hiddenMarcSubfields)) {
                            continue;
                        }
                        $labelKey = SucheinstiegePerson::$RENDER_CONFIG_PERSON_KEY . "-" . $subfieldNameStr;
                        $compoundEntry->addElement($labelKey, $subfieldNameStr);
                    }
                    $compoundEntry->orderEntries();
                    $ffdList = [];
                    foreach ($compoundEntry->elements as $singleEntry) {
                        $subfieldNameStr = $singleEntry->getSubfieldName();
                        $ffdList[] = $compoundEntry->buildFieldFormatterData($subfieldNameStr, $sfv[$subfieldNameStr], $context->solrMarc);
                    }
                    if (!array_key_exists($role, $personsWithRole)) {
                        $personsWithRole[$role] = [[$compoundEntry, $ffdList]];
                    } else {
                        $personsWithRole[$role][] = [$compoundEntry, $ffdList];
                    }
                }
            }
        }
        return $personsWithRole;
    }
}